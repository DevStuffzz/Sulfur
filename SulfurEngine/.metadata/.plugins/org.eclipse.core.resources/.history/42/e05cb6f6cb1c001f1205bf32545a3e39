import java.awt.Color;
import java.awt.image.BufferedImage;
import java.util.Random;

import com.sulfurengine.behaviorscripts.Spriterenderer;
import com.sulfurengine.ecs.Script;
import com.sulfurengine.io.Display;
import com.sulfurengine.renderer.Sprite;

public class RayTracer extends Script {

    BufferedImage image;
    private int width;
    private int height;

    private static final int SAMPLES_PER_PIXEL = 10; // Number of samples for anti-aliasing
    private Random random = new Random();

    // Sphere properties
    private static final Sphere[] spheres = {
        new Sphere(-100, 0, 0, 100, Color.RED),
        new Sphere(100, 0, 0, 100, Color.BLUE),
        new Sphere(0, 10010, 0, 10000, Color.white)
    };

    // Light properties
    private static final float[] LIGHT_POS = { 1.0f, -1.0f, -1.0f };
    private static final Color BACKGROUND_COLOR = Color.BLACK;

    @Override
    public void start() {
        width = Display.get().width();
        height = Display.get().height();
        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);

        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                image.setRGB(x, y, BACKGROUND_COLOR.getRGB()); // Set each pixel to white
            }
        }
    }

    @Override
    public void update(float dt) {
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                int pixel = pixelColor(x, y);
                image.setRGB(x, y, pixel);
            }
        }
        parent.getScript(Spriterenderer.class).getSprite().setImage(image);
    }

    public int pixelColor(int x, int y) {
        float r = 0;
        float g = 0;
        float b = 0;

        for (int i = 0; i < SAMPLES_PER_PIXEL; i++) {
            float offsetX = (float) (random.nextDouble() - 0.5);
            float offsetY = (float) (random.nextDouble() - 0.5);

            float worldX = x + offsetX - width / 2.0f;
            float worldY = y + offsetY - height / 2.0f;
            float worldZ = 0.0f;

            // Ray origin
            float rayOriginX = worldX;
            float rayOriginY = worldY;
            float rayOriginZ = -500.0f; // Assume the camera is at z = -500

            // Ray direction
            float rayDirX = 0.0f;
            float rayDirY = 0.0f;
            float rayDirZ = 1.0f;

            Color color = traceRay(rayOriginX, rayOriginY, rayOriginZ, rayDirX, rayDirY, rayDirZ, 1);

            r += color.getRed();
            g += color.getGreen();
            b += color.getBlue();
        }

        r /= SAMPLES_PER_PIXEL;
        g /= SAMPLES_PER_PIXEL;
        b /= SAMPLES_PER_PIXEL;

        return new Color((int) r, (int) g, (int) b).getRGB();
    }

    private Color traceRay(float rayOriginX, float rayOriginY, float rayOriginZ, float rayDirX, float rayDirY,
            float rayDirZ, int depth) {
        if (depth > 3) {
            return BACKGROUND_COLOR; // Limit recursion depth for reflections
        }

        Sphere closestSphere = null;
        float closestT = Float.MAX_VALUE;

        for (Sphere sphere : spheres) {
            float[] t = intersectRaySphere(rayOriginX, rayOriginY, rayOriginZ, rayDirX, rayDirY, rayDirZ, sphere);
            if (t[0] > 0 && t[0] < closestT) {
                closestT = t[0];
                closestSphere = sphere;
            }
            if (t[1] > 0 && t[1] < closestT) {
                closestT = t[1];
                closestSphere = sphere;
            }
        }

        if (closestSphere == null) {
            return BACKGROUND_COLOR; // No intersection, return background color
        }

        // Intersection point
        float hitX = rayOriginX + closestT * rayDirX;
        float hitY = rayOriginY + closestT * rayDirY;
        float hitZ = rayOriginZ + closestT * rayDirZ;

        // Normal at the intersection point
        float normalX = (hitX - closestSphere.centerX) / closestSphere.radius;
        float normalY = (hitY - closestSphere.centerY) / closestSphere.radius;
        float normalZ = (hitZ - closestSphere.centerZ) / closestSphere.radius;

        // Lambertian shading
        float lightDirX = LIGHT_POS[0];
        float lightDirY = LIGHT_POS[1];
        float lightDirZ = LIGHT_POS[2];

        // Normalize the light direction
        float lightLen = (float) Math.sqrt(lightDirX * lightDirX + lightDirY * lightDirY + lightDirZ * lightDirZ);
        lightDirX /= lightLen;
        lightDirY /= lightLen;
        lightDirZ /= lightLen;

        float dot = normalX * lightDirX + normalY * lightDirY + normalZ * lightDirZ;
        dot = Math.max(0, dot);

        int r = (int) (closestSphere.color.getRed() * dot);
        int g = (int) (closestSphere.color.getGreen() * dot);
        int b = (int) (closestSphere.color.getBlue() * dot);

        Color localColor = new Color(r, g, b);

        // Reflection
        float reflectX = rayDirX - 2 * dot * normalX;
        float reflectY = rayDirY - 2 * dot * normalY;
        float reflectZ = rayDirZ - 2 * dot * normalZ;

        Color reflectionColor = traceRay(hitX, hitY, hitZ, reflectX, reflectY, reflectZ, depth + 1);

        float reflectivity = 0.5f;
        r = (int) (localColor.getRed() * (1 - reflectivity) + reflectionColor.getRed() * reflectivity);
        g = (int) (localColor.getGreen() * (1 - reflectivity) + reflectionColor.getGreen() * reflectivity);
        b = (int) (localColor.getBlue() * (1 - reflectivity) + reflectionColor.getBlue() * reflectivity);

        return new Color(r, g, b);
    }

    private float[] intersectRaySphere(float rayOriginX, float rayOriginY, float rayOriginZ, float rayDirX,
            float rayDirY, float rayDirZ, Sphere sphere) {
        float ocX = rayOriginX - sphere.centerX;
        float ocY = rayOriginY - sphere.centerY;
        float ocZ = rayOriginZ - sphere.centerZ;

        float a = rayDirX * rayDirX + rayDirY * rayDirY + rayDirZ * rayDirZ;
        float b = 2.0f * (ocX * rayDirX + ocY * rayDirY + ocZ * rayDirZ);
        float c = ocX * ocX + ocY * ocY + ocZ * ocZ - sphere.radius * sphere.radius;

        float discriminant = b * b - 4 * a * c;

        if (discriminant < 0) {
            return new float[] { -1, -1 };
        } else {
            float t1 = (-b - (float) Math.sqrt(discriminant)) / (2.0f * a);
            float t2 = (-b + (float) Math.sqrt(discriminant)) / (2.0f * a);
            return new float[] { t1, t2 };
        }
    }

    private static class Sphere {
        float centerX, centerY, centerZ;
        float radius;
        Color color;

        Sphere(float centerX, float centerY, float centerZ, float radius, Color color) {
            this.centerX = centerX;
            this.centerY = centerY;
            this.centerZ = centerZ;
            this.radius = radius;
            this.color = color;
        }
    }
}
